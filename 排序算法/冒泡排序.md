
#### 冒泡排序算法思想及代码  

冒泡排序的思想就是依次比较两个相邻的元素，如果不满足顺序就交换两个元素。  
冒泡排序根据遍历的方向分为从左往右和从右往左。  
以从小到大排序，从左往右遍历为例：  

```
void bubbleSort (elemType arr[], int len) {
    elemType temp;
    int i, j;
    for (i=0; i<len-1; i++) /* 外循环为排序趟数，len个数进行len-1趟 */
        for (j=0; j<len-1-i; j++) { /* 内循环为每趟比较的次数，第i趟比较len-i次 */
            if (arr[j] > arr[j+1]) { /* 相邻元素比较，若逆序则交换（升序为左大于右，降序反之） */
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
}
```
内循环每次遍历时会将最大的值移动到最右边，所以内循环的右边边界每次都会减小1。  

![](resource/bubble_sort.gif)

从小到大排序，从右往左遍历：  
```
void bubble_sort(int arr[], int len)
{
        for (int i = 0; i < len - 1; i++)
        {
            for (int j = len - 1; j > i; j--)
            {
                if (arr[j] < arr[j - 1])
                {
                    int temp = arr[j];
                    arr[j] = arr[j - 1];
                    arr[j - 1] = temp;
                }
            }
        }
}
```
内循环每次从右往左遍历，将最小的值移动到最左边，所以内循环的左边边界每次减1。  

#### 时间空间复杂度分析  

* **时间复杂度**  
  如果初始状态是有序的，遍历一次即可，需要比较的次数 $C_{min}=n-1$, 交换次数$M_{min}=0$。因此**最好情况下的时间复杂度为$O\left(n\right)$**。  
  
  如果初始状态是逆序的，需要进行$n-1$趟排序。每趟排序要比较和交换 $n-i$ 次（$1<=i<=n-1$）。比较次数和交换次数均达到最大值：  
$$
C_{\max }=\frac{n(n-1)}{2}=O\left(n^{2}\right)
$$  
$$
M_{\max }=\frac{ n(n-1)}{2}=O\left(n^{2}\right)
$$  
这里将两个元素互换记为一次交换，实际操作中一次交换可能还需要三次赋值。
因此**最坏情况下的时间复杂度为$O\left(n^{2}\right)$**。  
当初始状态无序时，冒泡排序需要对序列做和逆序同样的操作（同样的比较次数，交换次数可能不同）。因此**平均时间复杂度为$O\left(n^{2}\right)$**。  


* **空间复杂度**  
    因为冒泡排序不需要分配额外空间，只需要临时变量用于交换，所以**空间复杂度为$O\left(1\right)$**。  

* **稳定性**  
  冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种**稳定排序算法**。


  **参考**  
  [1] https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F  
  [2] [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)  

