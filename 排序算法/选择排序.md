#### 选择排序算法思想及代码   

思想：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。  

选择排序和冒泡排序非常相似，前者是直接寻找最值，后者是通过不断交换找到最值。  
选择排序代码:  
```
void swap(int *a,int *b) //交換兩個變數
{
    int temp = *a;
    *a = *b;
    *b = temp;
}
void selection_sort(int arr[], int len) 
{
    int i,j;

	for (i = 0 ; i < len - 1 ; i++) 
    {
		int min = i;
		for (j = i + 1; j < len; j++)     //走訪未排序的元素
			if (arr[j] < arr[min])    //找到目前最小值
				min = j;    //紀錄最小值
	   	swap(&arr[min], &arr[i]);    //做交換
	}
}
```

![](resource/select_sort.gif)

#### 时间空间复杂度分析  

* **时间复杂度**  
  如果初始状态是有序的，遍历一次即可，需要比较的次数 $C_{min}=n-1$, 交换次数$M_{min}=0$。因此**最好情况下的时间复杂度为$O\left(n\right)$**。  
  如果初始状态是逆序的，比较次数和交换次数均达到最大值：  
$$
C_{\max }=\frac{n(n-1)}{2}=O\left(n^{2}\right)
$$  
$$
M_{\max }=n-1=O\left(n\right)
$$  
这里将两个元素互换记为一次交换，实际操作中一次交换可能还需要三次赋值。
因此**最坏情况下的时间复杂度为$O\left(n^{2}\right)$**。  
当初始状态无序时，选择排序需要对序列做和逆序同样的操作（同样的比较次数，交换次数可能不同）。因此**平均时间复杂度为$O\left(n^{2}\right)$**。 

* **空间复杂度**  
    因为冒泡排序不需要分配额外空间，只需要临时变量用于交换，所以**空间复杂度为$O\left(1\right)$**。  

* **稳定性**  
  **不稳定**  
  举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了。


选择排序的交换次数比冒泡排序要少，因此速度可能比冒泡排序块。


**参考**  
[1] https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F  
[2] [八大排序算法稳定性分析，原来稳定性是这个意思...](https://zhuanlan.zhihu.com/p/36120420)  
[3] [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)  


