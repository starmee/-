#### 插入排序的算法思想及代码  

插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 $O(1)$的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。  

代码：  
```
void insertion_sort(int arr[], int len){
        int i,j,key;
        for (i=1;i<len;i++){
                key = arr[i];
                j=i-1;
                while((j>=0) && (arr[j]>key)) {
                        arr[j+1] = arr[j];
                        j--;
                }
                arr[j+1] = key;
        }
}
```

![](resource/insert_sort.gif)  

#### 时间空间复杂度分析  

* **时间复杂度**  
  如果初始状态是有序的，遍历一次即可，需要比较的次数 $C_{min}=n-1$, 移动次数$M_{min}=0$。因此**最好情况下的时间复杂度为$O\left(n\right)$**。  
  如果初始状态是逆序的，每在已排序序列中插入一次寻元素都需要对已排序序列的每个元素做一次比较和右移，共需要插入n-1次。比较次数和移动次数达到最大：  
  $$
C_{\max }=\frac{n(n-1)}{2}=O\left(n^{2}\right)
$$  
$$
M_{\max }=\frac{ n(n-1)}{2}=O\left(n^{2}\right)
$$  
因此**最坏情况下的时间复杂度为$O\left(n^{2}\right)$**。  
如果初始状态是乱序的，需要做和逆序同样的处理（同样的比较次数，移动次数可能不同）。因此**平均时间复杂度为$O\left(n^{2}\right)$**。 


* **空间复杂度**  
    因为选择排序不需要分配额外空间，只需要临时变量用于移动，所以**空间复杂度为$O\left(1\right)$**。  


* **稳定性**  
  相同元素的前后顺序不会发生改变，是**稳定**算法。  

**参考**  
[1] https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F  
[2] [八大排序算法稳定性分析，原来稳定性是这个意思...](https://zhuanlan.zhihu.com/p/36120420)  
[3] [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)    